## FSS是什么？
基于.NET CORE 5 分布式的任务调度平台，包含服务端、客户端。

服务端：会运行在docker环境下（唯一推荐使用）

客户端：就是我们自己的JOB程序，可以是控制台（Console）程序，也可以ASP.NET CORE程序

服务端与客户端之间采用Grpc通讯

客户端（JOB）可以多实例运行（比如K8S中副本设为3），由调度平台（服务端）根据时间策略进行远程调度。

与.NET CORE高度契合，利用Farseer.Net.Job组件，可以实现非常简单的接入

这样就实现了调度与JOB的物理解耦，我们只要关注JOB的业务逻辑编写。
## 服务端依赖环境
    Docker （运行在docker或k8s下）
    Net 5.0 （提供docker.hub镜像服务)
    Redis （用与客户端的实例注册）
    Sqlserver/MySql/Oracle（常用数据库任意选一个）
    Grpc （通讯协议，后期考虑REST API)

## 客户端依赖环境
    netstandard2.0
    AppSettins.json （配置服务端通讯地址）
    Farseer.Net.Job 方便快速集成到业务系统（如不依赖，需自行对接）
    Grpc（Farseer.Net.Job会实现服务的创建）

## 设计目标
高可用（HA）：业务方提供多实例的job运行。同一个任务、同一个job实例只会被调度一次

快速搭建：运行于docker或k8s下，提供一键部署，1分钟即可把服务部署到您的生产环境中

轻量级：极低的内存、CPU消耗，快速运行，依赖少。

动态的执行触发器：可定时、间隔时间、或由业务方job动态返回下次执行时间。

可观性：job的执行日志、执行时间、耗时能全面记录在服务端，供运维了解任务的执行情况

快速上手：借助Farseer.Net.Job组件（开源在github，并提供nuget包），可以快速实现一个job

## 客户端启动
通过Farseer.Net.Job组件，运行job的程序在启动之后会做：

    1、会向调度平台注册（Grpc协议）客户端的信息。并自行维护心跳以告知业务方，当前客户端的存活
    2、会启动Grpc服务（端口可配置），用于接收调度平台的消息通知

## 服务端与客户端通讯
如前面叙述，本项目希望是建立一套极简、依赖少的调度平台。

因此本项目采用的通讯方案：

    1、当调度器开始工作时，会通过客户端列表（客户端启动后注册进来），以轮询的方式取出其中一个客户端开启的Grpc服务并调用。
    2、客户端在收到要执行的任务时，开始工作。在工作的过程中，会通知服务端告知当前的状态、进度。

## 任务组
任务组：是要执行任务的基本信息：任务名称、开始时间、执行次数、执行耗时、启用状态、下一次执行的任务ID。

任务：是在任务组设定并启用后动态创建并由系统自动维护的任务信息，可以知道某次的任务是由哪个客户端执行，执行状态（成功、失败），执行耗时等信息。

    当任务组启用后，会创建一条任务信息，并标记为该任务的执行开始时间，是否执行的状态。调度器通过这个任务建立时间轮，来轮询时间格。